(()=>{"use strict";const e="struct Fragment {\r\n    @builtin(position) Position : vec4<f32>, // builtin screen ka pposition\r\n    @location(0) @interpolate(flat) Color : vec4<f32> // location in the vertex buffer\r\n};\r\n\r\n@vertex\r\nfn vs_main(@location(0) vertexPosition: vec2<f32>, @location(1) vertexColor : vec3<f32>) -> Fragment {\r\n\r\n    var output : Fragment;\r\n    output.Position = vec4<f32>(vertexPosition, 0.0, 1.0);\r\n    output.Color = vec4<f32>(vertexColor, 1.0);\r\n\r\n    return output;\r\n}\r\n\r\n@fragment\r\nfn fs_main(@location(0) @interpolate(flat) Color: vec4<f32>) -> @location(0) vec4<f32> {\r\n    return Color;\r\n}\r\n\r\n// what are these function parameters\r\n// what is that fragment shader, how tf is that working";class t{constructor(e,t){if(3!=t.length||t.some(e=>2!=e.length))throw new Error("expected 3 vertices on the triangle mesh, each with [x,y]");const i=new Float32Array([t[0][0],t[0][1],0,0,0,t[1][0],t[1][1],0,0,0,t[2][0],t[2][1],0,0,0]),r=GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,n={size:i.byteLength,usage:r,mappedAtCreation:!0};this.buffer=e.createBuffer(n),new Float32Array(this.buffer.getMappedRange()).set(i),this.buffer.unmap(),this.bufferLayout={arrayStride:20,attributes:[{shaderLocation:0,format:"float32x2",offset:0},{shaderLocation:1,format:"float32x3",offset:8}]}}}var i=function(e,t,i,r){return new(i||(i=Promise))(function(n,o){function s(e){try{u(r.next(e))}catch(e){o(e)}}function a(e){try{u(r.throw(e))}catch(e){o(e)}}function u(e){var t;e.done?n(e.value):(t=e.value,t instanceof i?t:new i(function(e){e(t)})).then(s,a)}u((r=r.apply(e,t||[])).next())})};let r,n=0;class o{constructor(e,t){this.maxParticles=1e4,this.mousePosition={x:0,y:0},this.mousePressed=!1,this.brushSize=.05,this.brushPressure=1,this.device=e,this.canvas=t}initialize(){return i(this,void 0,void 0,function*(){yield this.createBuffers(),yield this.createPipelines(),this.setupEventListeners()})}createBuffers(){return i(this,void 0,void 0,function*(){const e=56*this.maxParticles;this.particleBuffer=this.device.createBuffer({size:e,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.VERTEX,mappedAtCreation:!1}),this.uniformBuffer=this.device.createBuffer({size:64,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})})}createPipelines(){return i(this,void 0,void 0,function*(){const e=yield fetch("./brush_simulation.wgsl").then(e=>e.text()),t=this.device.createShaderModule({code:e});this.computePipeline=this.device.createComputePipeline({layout:"auto",compute:{module:t,entryPoint:"updateParticles"}}),this.computePipelineSpawn=this.device.createComputePipeline({layout:"auto",compute:{module:t,entryPoint:"spawnParticles"}}),this.bindGroup=this.device.createBindGroup({layout:this.computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.particleBuffer}},{binding:1,resource:{buffer:this.uniformBuffer}}]})})}setupEventListeners(){this.canvas.addEventListener("mousedown",e=>{this.mousePressed=!0,this.updateMousePosition(e)}),this.canvas.addEventListener("mousemove",e=>{this.updateMousePosition(e)}),this.canvas.addEventListener("mouseup",()=>{this.mousePressed=!1})}updateMousePosition(e){const t=this.canvas.getBoundingClientRect();this.mousePosition.x=(e.clientX-t.left)/t.width*2-1,this.mousePosition.y=-((e.clientY-t.top)/t.height*2-1)}update(e){const t=new Float32Array([e,0,-.5,.1,.2,this.mousePosition.x,this.mousePosition.y,this.brushPressure,this.brushSize,this.mousePressed?1:0]);this.device.queue.writeBuffer(this.uniformBuffer,0,t);const i=this.device.createCommandEncoder(),r=i.beginComputePass();r.setPipeline(this.computePipelineSpawn),r.setBindGroup(0,this.bindGroup),r.dispatchWorkgroups(Math.ceil(this.maxParticles/64),1,1),r.end();const n=i.beginComputePass();n.setPipeline(this.computePipeline),n.setBindGroup(0,this.bindGroup),n.dispatchWorkgroups(Math.ceil(this.maxParticles/64),1,1),n.end(),this.device.queue.submit([i.finish()])}}!function(){i(this,void 0,void 0,function*(){var i;const s=document.getElementById("gfx-main"),a=yield null===(i=navigator.gpu)||void 0===i?void 0:i.requestAdapter(),u=yield null==a?void 0:a.requestDevice(),c=s.getContext("webgpu"),f="bgra8unorm";c.configure({device:u,format:f,alphaMode:"opaque"}),r=new o(u,s),yield r.initialize();const h=[new Float32Array([0,.05]),new Float32Array([-.05,-.05]),new Float32Array([.05,-.05])],l=[new Float32Array([.05,.15]),new Float32Array([0,.05]),new Float32Array([.1,.05])],d=new t(u,h),p=new t(u,l),m=u.createRenderPipeline({vertex:{module:u.createShaderModule({code:e}),entryPoint:"vs_main",buffers:[d.bufferLayout]},fragment:{module:u.createShaderModule({code:e}),entryPoint:"fs_main",targets:[{format:f}]},primitive:{topology:"triangle-list"},layout:"auto"});requestAnimationFrame(function e(t){n||(n=t);const i=(t-n)/1e3;n=t,r.update(i);const o=u.createCommandEncoder(),s=c.getCurrentTexture().createView(),a=o.beginRenderPass({colorAttachments:[{view:s,clearValue:{r:1,g:1,b:1,a:0},loadOp:"clear",storeOp:"store"}]});a.setPipeline(m),a.setVertexBuffer(0,d.buffer),a.draw(3,1,0,0),a.setVertexBuffer(0,p.buffer),a.draw(3,1,0,0),a.end(),u.queue.submit([o.finish()]),requestAnimationFrame(e)})})}()})();